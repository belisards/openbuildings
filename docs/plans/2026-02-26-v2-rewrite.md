# Overture Buildings Explorer v2 - Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a performant, open-source building footprint explorer for development practitioners using FastAPI + DuckDB backend and React + Deck.gl frontend.

**Architecture:** FastAPI serves a React SPA and exposes REST endpoints that query Overture Maps Parquet files on S3 via DuckDB with spatial extensions. The frontend renders 100K+ building polygons on a full-screen WebGL map with floating overlay panels for area selection, stats, and export.

**Tech Stack:** Python 3.11+ / FastAPI / DuckDB (spatial + httpfs) / React 18 / TypeScript / Deck.gl 9 / MapLibre GL JS / Tailwind CSS / Vite

---

## Task 1: Project Scaffolding

**Files:**
- Create: `pyproject.toml`
- Create: `backend/app/__init__.py`
- Create: `backend/app/main.py`
- Create: `frontend/package.json`
- Create: `frontend/vite.config.ts`
- Create: `frontend/tsconfig.json`
- Create: `frontend/index.html`
- Create: `frontend/src/main.tsx`
- Create: `frontend/src/App.tsx`
- Create: `.gitignore`
- Create: `README.md`
- Create: `CLAUDE.md`

**Step 1: Create root pyproject.toml for backend**

```toml
[project]
name = "openbuildings"
version = "0.1.0"
description = "Overture Buildings Explorer - building footprint data for development practitioners"
requires-python = ">=3.11"
dependencies = [
    "fastapi>=0.115.0",
    "uvicorn[standard]>=0.32.0",
    "duckdb>=1.2.0",
    "shapely>=2.0.6",
    "pydantic>=2.0.0",
]

[tool.uv]
dev-dependencies = [
    "pytest>=8.0.0",
    "httpx>=0.27.0",
]
```

**Step 2: Create minimal FastAPI backend**

`backend/app/__init__.py` - empty file

`backend/app/main.py`:
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI(title="Overture Buildings Explorer")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173"],
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/api/health")
async def health():
    return {"status": "ok"}
```

**Step 3: Scaffold React + Deck.gl frontend**

Run:
```bash
cd frontend && npm create vite@latest . -- --template react-ts
npm install @deck.gl/core@^9.2 @deck.gl/layers@^9.2 @deck.gl/react@^9.2 @deck.gl/mapbox@^9.2 maplibre-gl@^5 react-map-gl@^8.1 tailwindcss@^4
npm install -D @types/react @types/react-dom
```

`frontend/vite.config.ts`:
```ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    proxy: {
      '/api': 'http://localhost:8000',
    },
  },
  build: {
    target: 'esnext',
    outDir: 'dist',
  },
});
```

`frontend/src/App.tsx`:
```tsx
function App() {
  return <div style={{ width: '100vw', height: '100vh', background: '#1a1a2e', color: '#fff', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
    <h1>Overture Buildings Explorer</h1>
  </div>;
}
export default App;
```

**Step 4: Create .gitignore**

```
node_modules/
dist/
__pycache__/
*.pyc
.venv/
.env
*.egg-info/
```

**Step 5: Create CLAUDE.md**

```markdown
# Overture Buildings Explorer

## Quick Start
- Backend: `uv run uvicorn backend.app.main:app --reload`
- Frontend: `cd frontend && npm run dev`

## Architecture
- `backend/` - FastAPI + DuckDB (Python)
- `frontend/` - React + Deck.gl + MapLibre (TypeScript)

## Conventions
- Use uv for Python dependency management
- Use npm for frontend
- API endpoints under `/api/`
- Backend serves frontend static build in production
```

**Step 6: Create README.md**

```markdown
# Overture Buildings Explorer

Interactive explorer for building footprints from the [Overture Maps](https://overturemaps.org/) dataset. Built for development practitioners who need building data for planning, disaster response, and urbanization analysis.

## Features
- Full-screen WebGL map with satellite imagery
- Query building footprints by drawing areas or uploading GeoJSON
- Building metadata: height, floors, classification, data sources
- Export results as GeoJSON

## Quick Start

### Backend
```bash
uv sync
uv run uvicorn backend.app.main:app --reload
```

### Frontend
```bash
cd frontend
npm install
npm run dev
```

Open http://localhost:5173

## Tech Stack
- **Backend:** FastAPI + DuckDB (queries Overture Parquet on S3)
- **Frontend:** React + Deck.gl + MapLibre GL JS
```

**Step 7: Verify both servers start**

Run: `uv sync && uv run uvicorn backend.app.main:app --port 8000 &`
Expected: FastAPI running on :8000

Run: `cd frontend && npm install && npm run dev &`
Expected: Vite dev server on :5173

Run: `curl http://localhost:8000/api/health`
Expected: `{"status":"ok"}`

**Step 8: Commit**

```bash
git add -A
git commit -m "feat: scaffold project with FastAPI backend and React frontend"
```

---

## Task 2: DuckDB Query Engine

**Files:**
- Create: `backend/app/core/__init__.py`
- Create: `backend/app/core/config.py`
- Create: `backend/app/core/duckdb.py`
- Create: `backend/tests/__init__.py`
- Create: `backend/tests/test_duckdb.py`

**Step 1: Write failing test for DuckDB connection**

`backend/tests/test_duckdb.py`:
```python
from backend.app.core.duckdb import get_connection

def test_duckdb_connection_has_spatial():
    con = get_connection()
    result = con.execute("SELECT ST_Point(0, 0)").fetchone()
    assert result is not None

def test_duckdb_connection_has_httpfs():
    con = get_connection()
    result = con.execute("SELECT current_setting('s3_region')").fetchone()
    assert result[0] == "us-west-2"
```

**Step 2: Run test to verify it fails**

Run: `uv run pytest backend/tests/test_duckdb.py -v`
Expected: FAIL - module not found

**Step 3: Implement config and DuckDB module**

`backend/app/core/__init__.py` - empty

`backend/app/core/config.py`:
```python
OVERTURE_RELEASE = "2026-02-18.0"
OVERTURE_S3_PATH = f"s3://overturemaps-us-west-2/release/{OVERTURE_RELEASE}/theme=buildings/type=building/*"
DEFAULT_FEATURE_LIMIT = 50_000
```

`backend/app/core/duckdb.py`:
```python
import duckdb

_connection = None

def get_connection() -> duckdb.DuckDBPyConnection:
    global _connection
    if _connection is None:
        _connection = duckdb.connect()
        _connection.install_extension("spatial")
        _connection.install_extension("httpfs")
        _connection.load_extension("spatial")
        _connection.load_extension("httpfs")
        _connection.execute("SET s3_region = 'us-west-2'")
    return _connection
```

**Step 4: Run test to verify it passes**

Run: `uv run pytest backend/tests/test_duckdb.py -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/app/core/ backend/tests/
git commit -m "feat: add DuckDB connection with spatial and httpfs extensions"
```

---

## Task 3: Building Query Function

**Files:**
- Create: `backend/app/core/queries.py`
- Create: `backend/tests/test_queries.py`

**Step 1: Write failing test for building query**

`backend/tests/test_queries.py`:
```python
import json
from backend.app.core.queries import query_buildings

# Small area in Nairobi (few buildings, fast query)
NAIROBI_POLYGON = {
    "type": "Polygon",
    "coordinates": [[
        [36.817, -1.283],
        [36.820, -1.283],
        [36.820, -1.280],
        [36.817, -1.280],
        [36.817, -1.283],
    ]]
}

def test_query_buildings_returns_feature_collection():
    result = query_buildings(NAIROBI_POLYGON, limit=10)
    assert result["type"] == "FeatureCollection"
    assert isinstance(result["features"], list)

def test_query_buildings_has_properties():
    result = query_buildings(NAIROBI_POLYGON, limit=5)
    if result["features"]:
        feature = result["features"][0]
        assert "geometry" in feature
        assert "properties" in feature
        assert feature["geometry"]["type"] in ("Polygon", "MultiPolygon")
```

**Step 2: Run test to verify it fails**

Run: `uv run pytest backend/tests/test_queries.py -v`
Expected: FAIL - module not found

**Step 3: Implement building query**

`backend/app/core/queries.py`:
```python
import json
from typing import Any

from shapely.geometry import shape, mapping
from shapely import wkt

from backend.app.core.config import OVERTURE_S3_PATH, DEFAULT_FEATURE_LIMIT
from backend.app.core.duckdb import get_connection


def query_buildings(geometry: dict[str, Any], limit: int = DEFAULT_FEATURE_LIMIT) -> dict[str, Any]:
    """Query Overture buildings that intersect the given GeoJSON geometry."""
    geom = shape(geometry)
    bounds = geom.bounds  # (minx, miny, maxx, maxy)
    geom_wkt = geom.wkt

    con = get_connection()

    sql = f"""
    SELECT
        id,
        ST_AsGeoJSON(ST_GeomFromWKB(geometry)) AS geojson_geom,
        height,
        num_floors,
        class,
        subtype,
        names.primary AS primary_name,
        facade_color,
        facade_material,
        roof_material,
        roof_shape,
        roof_color,
        JSON(sources) AS sources
    FROM read_parquet('{OVERTURE_S3_PATH}', filename=true, hive_partitioning=1)
    WHERE
        bbox.xmin >= $1 AND bbox.xmax <= $2
        AND bbox.ymin >= $3 AND bbox.ymax <= $4
        AND ST_Intersects(ST_GeomFromWKB(geometry), ST_GeomFromText($5))
    LIMIT $6
    """

    result = con.execute(sql, [bounds[0], bounds[2], bounds[1], bounds[3], geom_wkt, limit])
    rows = result.fetchall()
    columns = [desc[0] for desc in result.description]

    features = []
    for row in rows:
        record = dict(zip(columns, row))
        geojson_geom = json.loads(record.pop("geojson_geom"))

        properties = {}
        for key, value in record.items():
            if value is not None:
                if key == "sources":
                    properties[key] = json.loads(value) if isinstance(value, str) else value
                else:
                    properties[key] = value

        features.append({
            "type": "Feature",
            "geometry": geojson_geom,
            "properties": properties,
        })

    return {"type": "FeatureCollection", "features": features}
```

**Step 4: Run test to verify it passes**

Run: `uv run pytest backend/tests/test_queries.py -v --timeout=120`
Expected: PASS (first query may take 30-60s as DuckDB downloads Parquet metadata)

**Step 5: Commit**

```bash
git add backend/app/core/queries.py backend/tests/test_queries.py
git commit -m "feat: add DuckDB building query with spatial filtering"
```

---

## Task 4: API Endpoints

**Files:**
- Create: `backend/app/api/__init__.py`
- Create: `backend/app/api/buildings.py`
- Create: `backend/app/models/__init__.py`
- Create: `backend/app/models/schemas.py`
- Modify: `backend/app/main.py`
- Create: `backend/tests/test_api.py`

**Step 1: Write failing test for API**

`backend/tests/test_api.py`:
```python
from fastapi.testclient import TestClient
from backend.app.main import app

client = TestClient(app)

NAIROBI_POLYGON = {
    "type": "Polygon",
    "coordinates": [[
        [36.817, -1.283],
        [36.820, -1.283],
        [36.820, -1.280],
        [36.817, -1.280],
        [36.817, -1.283],
    ]]
}

def test_health():
    response = client.get("/api/health")
    assert response.status_code == 200
    assert response.json()["status"] == "ok"

def test_buildings_endpoint():
    response = client.post("/api/buildings", json={
        "geometry": NAIROBI_POLYGON,
        "limit": 5,
    })
    assert response.status_code == 200
    data = response.json()
    assert data["type"] == "FeatureCollection"
    assert "metadata" in data

def test_buildings_stats_endpoint():
    response = client.post("/api/buildings/stats", json={
        "geometry": NAIROBI_POLYGON,
        "limit": 10,
    })
    assert response.status_code == 200
    data = response.json()
    assert "total_buildings" in data
```

**Step 2: Run test to verify it fails**

Run: `uv run pytest backend/tests/test_api.py -v`
Expected: FAIL - endpoint not found

**Step 3: Create Pydantic schemas**

`backend/app/models/__init__.py` - empty

`backend/app/models/schemas.py`:
```python
from typing import Any
from pydantic import BaseModel

class BuildingQuery(BaseModel):
    geometry: dict[str, Any]
    limit: int = 50_000

class BuildingStats(BaseModel):
    total_buildings: int
    height_coverage_pct: float
    floor_coverage_pct: float
    class_coverage_pct: float
    avg_height: float | None
    source_breakdown: dict[str, int]
```

**Step 4: Create API routes**

`backend/app/api/__init__.py` - empty

`backend/app/api/buildings.py`:
```python
import json
from fastapi import APIRouter
from fastapi.responses import StreamingResponse
from io import BytesIO

from backend.app.models.schemas import BuildingQuery, BuildingStats
from backend.app.core.queries import query_buildings
from backend.app.core.config import OVERTURE_RELEASE

router = APIRouter(prefix="/api")

@router.post("/buildings")
async def get_buildings(query: BuildingQuery):
    geojson = query_buildings(query.geometry, limit=query.limit)
    stats = _compute_stats(geojson["features"])
    return {
        **geojson,
        "metadata": {
            "total_buildings": len(geojson["features"]),
            "truncated": len(geojson["features"]) >= query.limit,
            "overture_release": OVERTURE_RELEASE,
            **stats,
        }
    }

@router.post("/buildings/stats")
async def get_building_stats(query: BuildingQuery):
    geojson = query_buildings(query.geometry, limit=query.limit)
    features = geojson["features"]
    stats = _compute_stats(features)
    return {"total_buildings": len(features), **stats}

@router.post("/export")
async def export_buildings(query: BuildingQuery):
    geojson = query_buildings(query.geometry, limit=query.limit)
    content = json.dumps(geojson, separators=(",", ":"))
    return StreamingResponse(
        BytesIO(content.encode()),
        media_type="application/geo+json",
        headers={"Content-Disposition": "attachment; filename=overture_buildings.geojson"},
    )

def _compute_stats(features: list) -> dict:
    heights = [f["properties"]["height"] for f in features if f["properties"].get("height")]
    floors = [f["properties"]["num_floors"] for f in features if f["properties"].get("num_floors")]
    classes = [f["properties"]["class"] for f in features if f["properties"].get("class")]

    source_counts: dict[str, int] = {}
    for f in features:
        sources = f["properties"].get("sources")
        if sources and isinstance(sources, list) and sources:
            dataset = sources[0].get("dataset", "Unknown")
            source_counts[dataset] = source_counts.get(dataset, 0) + 1

    total = len(features)
    return {
        "height_coverage_pct": round(len(heights) / total * 100) if total else 0,
        "floor_coverage_pct": round(len(floors) / total * 100) if total else 0,
        "class_coverage_pct": round(len(classes) / total * 100) if total else 0,
        "avg_height": round(sum(heights) / len(heights), 1) if heights else None,
        "source_breakdown": source_counts,
    }
```

**Step 5: Register routes in main.py**

Update `backend/app/main.py`:
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from backend.app.api.buildings import router
from backend.app.core.config import OVERTURE_RELEASE

app = FastAPI(title="Overture Buildings Explorer")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173"],
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(router)

@app.get("/api/health")
async def health():
    return {"status": "ok", "overture_release": OVERTURE_RELEASE}
```

**Step 6: Run tests**

Run: `uv run pytest backend/tests/test_api.py -v --timeout=120`
Expected: PASS

**Step 7: Commit**

```bash
git add backend/app/api/ backend/app/models/ backend/app/main.py backend/tests/test_api.py
git commit -m "feat: add buildings API endpoints with stats and export"
```

---

## Task 5: Full-Screen Map with Deck.gl

**Files:**
- Create: `frontend/src/components/MapView.tsx`
- Modify: `frontend/src/App.tsx`
- Create: `frontend/src/hooks/useMapState.ts`
- Create: `frontend/src/types/index.ts`

**Step 1: Install remaining dependencies**

Run:
```bash
cd frontend
npm install @deck.gl/core@^9.2 @deck.gl/layers@^9.2 @deck.gl/react@^9.2 @deck.gl/mapbox@^9.2 maplibre-gl@^5 react-map-gl@^8.1 tailwindcss@^4
```

**Step 2: Create types**

`frontend/src/types/index.ts`:
```ts
export interface BuildingProperties {
  id: string;
  height?: number;
  num_floors?: number;
  class?: string;
  subtype?: string;
  primary_name?: string;
  sources?: Array<{ dataset: string; record_id?: string }>;
}

export interface BuildingMetadata {
  total_buildings: number;
  truncated: boolean;
  overture_release: string;
  height_coverage_pct: number;
  floor_coverage_pct: number;
  class_coverage_pct: number;
  avg_height: number | null;
  source_breakdown: Record<string, number>;
}

export interface MapViewState {
  longitude: number;
  latitude: number;
  zoom: number;
  pitch: number;
  bearing: number;
}
```

**Step 3: Create map state hook**

`frontend/src/hooks/useMapState.ts`:
```ts
import { useState } from 'react';
import type { MapViewState } from '../types';

const DEFAULT_VIEW: MapViewState = {
  longitude: 36.82,
  latitude: -1.28,
  zoom: 12,
  pitch: 0,
  bearing: 0,
};

export function useMapState(initial?: Partial<MapViewState>) {
  const [viewState, setViewState] = useState<MapViewState>({
    ...DEFAULT_VIEW,
    ...initial,
  });

  return { viewState, setViewState };
}
```

**Step 4: Create MapView component**

`frontend/src/components/MapView.tsx`:
```tsx
import { useMemo } from 'react';
import { Map, useControl } from 'react-map-gl/maplibre';
import { MapboxOverlay } from '@deck.gl/mapbox';
import { GeoJsonLayer } from '@deck.gl/layers';
import type { DeckProps, PickingInfo } from '@deck.gl/core';
import 'maplibre-gl/dist/maplibre-gl.css';

interface MapViewProps {
  buildingData: GeoJSON.FeatureCollection | null;
  areaData: GeoJSON.FeatureCollection | null;
  opacity: number;
  viewState: { longitude: number; latitude: number; zoom: number; pitch: number; bearing: number };
  onViewStateChange: (vs: any) => void;
  onHover?: (info: PickingInfo) => void;
}

function DeckGLOverlay(props: DeckProps) {
  const overlay = useControl<MapboxOverlay>(() => new MapboxOverlay(props));
  overlay.setProps(props);
  return null;
}

const SATELLITE_STYLE = {
  version: 8 as const,
  sources: {
    'arcgis-imagery': {
      type: 'raster' as const,
      tiles: ['https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'],
      tileSize: 256,
    },
  },
  layers: [{
    id: 'arcgis-imagery',
    type: 'raster' as const,
    source: 'arcgis-imagery',
  }],
};

export function MapView({ buildingData, areaData, opacity, viewState, onViewStateChange, onHover }: MapViewProps) {
  const layers = useMemo(() => {
    const result = [];

    if (areaData) {
      result.push(new GeoJsonLayer({
        id: 'area-selection',
        data: areaData,
        filled: true,
        stroked: true,
        getFillColor: [51, 136, 255, 50],
        getLineColor: [51, 136, 255, 200],
        getLineWidth: 2,
        lineWidthUnits: 'pixels',
      }));
    }

    if (buildingData) {
      result.push(new GeoJsonLayer({
        id: 'buildings',
        data: buildingData,
        filled: true,
        stroked: true,
        getFillColor: [255, 120, 0, Math.round(opacity * 100)],
        getLineColor: [255, 120, 0, Math.round(opacity * 255)],
        getLineWidth: 1,
        lineWidthUnits: 'pixels',
        pickable: true,
        autoHighlight: true,
        highlightColor: [255, 200, 0, 180],
        onHover,
      }));
    }

    return result;
  }, [buildingData, areaData, opacity, onHover]);

  return (
    <Map
      {...viewState}
      onMove={evt => onViewStateChange(evt.viewState)}
      mapStyle={SATELLITE_STYLE}
      style={{ width: '100%', height: '100%' }}
    >
      <DeckGLOverlay layers={layers} />
    </Map>
  );
}
```

**Step 5: Update App.tsx**

`frontend/src/App.tsx`:
```tsx
import { useState, useCallback } from 'react';
import { MapView } from './components/MapView';
import { useMapState } from './hooks/useMapState';
import type { PickingInfo } from '@deck.gl/core';

function App() {
  const { viewState, setViewState } = useMapState();
  const [opacity, setOpacity] = useState(0.6);
  const [hoverInfo, setHoverInfo] = useState<PickingInfo | null>(null);

  const onHover = useCallback((info: PickingInfo) => {
    setHoverInfo(info.object ? info : null);
  }, []);

  return (
    <div style={{ width: '100vw', height: '100vh', position: 'relative' }}>
      <MapView
        buildingData={null}
        areaData={null}
        opacity={opacity}
        viewState={viewState}
        onViewStateChange={setViewState}
        onHover={onHover}
      />

      {hoverInfo?.object && (
        <div style={{
          position: 'absolute',
          left: (hoverInfo as any).x + 10,
          top: (hoverInfo as any).y + 10,
          background: 'rgba(0,0,0,0.85)',
          color: '#fff',
          padding: '8px 12px',
          borderRadius: 6,
          fontSize: 13,
          pointerEvents: 'none',
          zIndex: 10,
        }}>
          <strong>{(hoverInfo.object as any).properties?.primary_name || 'Building'}</strong>
          {(hoverInfo.object as any).properties?.height && (
            <div>Height: {(hoverInfo.object as any).properties.height}m</div>
          )}
          {(hoverInfo.object as any).properties?.class && (
            <div>Class: {(hoverInfo.object as any).properties.class}</div>
          )}
        </div>
      )}
    </div>
  );
}

export default App;
```

**Step 6: Verify map renders**

Run: `cd frontend && npm run dev`
Open: http://localhost:5173
Expected: Full-screen satellite map centered on Nairobi

**Step 7: Commit**

```bash
git add frontend/src/
git commit -m "feat: add full-screen Deck.gl map with satellite basemap"
```

---

## Task 6: Area Selection Panel (File Upload + Draw)

**Files:**
- Create: `frontend/src/components/AreaSelector.tsx`
- Modify: `frontend/src/App.tsx`

**Step 1: Install drawing library**

Run: `cd frontend && npm install @deck.gl-community/editable-layers`

**Step 2: Create AreaSelector component**

`frontend/src/components/AreaSelector.tsx`:
```tsx
import { useCallback, useRef, useState } from 'react';

interface AreaSelectorProps {
  onAreaSelected: (geojson: GeoJSON.FeatureCollection) => void;
  onFetchBuildings: () => void;
  isLoading: boolean;
}

export function AreaSelector({ onAreaSelected, onFetchBuildings, isLoading }: AreaSelectorProps) {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [features, setFeatures] = useState<GeoJSON.Feature[]>([]);
  const [selectedNames, setSelectedNames] = useState<string[]>([]);

  const handleFileUpload = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const geojson = JSON.parse(event.target?.result as string);
        const feats = geojson.features || [];
        setFeatures(feats);
        const names = feats.map((f: GeoJSON.Feature, i: number) =>
          f.properties?.name || `Feature ${i + 1}`
        );
        setSelectedNames(names);
        onAreaSelected({ type: 'FeatureCollection', features: feats });
      } catch {
        alert('Invalid GeoJSON file');
      }
    };
    reader.readAsText(file);
  }, [onAreaSelected]);

  const handleSelectionChange = useCallback((name: string) => {
    setSelectedNames(prev => {
      const next = prev.includes(name) ? prev.filter(n => n !== name) : [...prev, name];
      const selected = features.filter((f, i) =>
        next.includes(f.properties?.name || `Feature ${i + 1}`)
      );
      onAreaSelected({ type: 'FeatureCollection', features: selected });
      return next;
    });
  }, [features, onAreaSelected]);

  const featureNames = features.map((f, i) => f.properties?.name || `Feature ${i + 1}`);

  return (
    <div className="absolute top-4 left-4 bg-white/95 backdrop-blur rounded-lg shadow-lg p-4 w-72 z-10">
      <h3 className="font-semibold text-gray-800 mb-3">Area Selection</h3>

      <input
        ref={fileInputRef}
        type="file"
        accept=".geojson,.json"
        onChange={handleFileUpload}
        className="hidden"
      />
      <button
        onClick={() => fileInputRef.current?.click()}
        className="w-full px-3 py-2 bg-gray-100 hover:bg-gray-200 rounded text-sm text-gray-700 mb-3 transition"
      >
        Upload GeoJSON
      </button>

      {featureNames.length > 0 && (
        <div className="mb-3 max-h-40 overflow-y-auto">
          {featureNames.map(name => (
            <label key={name} className="flex items-center gap-2 py-1 text-sm text-gray-700 cursor-pointer">
              <input
                type="checkbox"
                checked={selectedNames.includes(name)}
                onChange={() => handleSelectionChange(name)}
              />
              {name}
            </label>
          ))}
        </div>
      )}

      {features.length > 0 && (
        <button
          onClick={onFetchBuildings}
          disabled={isLoading || selectedNames.length === 0}
          className="w-full px-3 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-300 text-white rounded text-sm font-medium transition"
        >
          {isLoading ? 'Fetching...' : 'Fetch Buildings'}
        </button>
      )}
    </div>
  );
}
```

**Step 3: Wire AreaSelector into App.tsx**

Add to `App.tsx` imports and state:
```tsx
import { AreaSelector } from './components/AreaSelector';

// Add state inside App():
const [areaData, setAreaData] = useState<GeoJSON.FeatureCollection | null>(null);
const [buildingData, setBuildingData] = useState<GeoJSON.FeatureCollection | null>(null);
const [isLoading, setIsLoading] = useState(false);

const handleFetchBuildings = useCallback(async () => {
  if (!areaData?.features.length) return;
  setIsLoading(true);
  try {
    const response = await fetch('/api/buildings', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ geometry: areaData.features[0].geometry, limit: 50000 }),
    });
    const data = await response.json();
    setBuildingData(data);
  } catch (err) {
    console.error('Failed to fetch buildings:', err);
  } finally {
    setIsLoading(false);
  }
}, [areaData]);
```

Add to JSX after MapView:
```tsx
<AreaSelector
  onAreaSelected={setAreaData}
  onFetchBuildings={handleFetchBuildings}
  isLoading={isLoading}
/>
```

Pass `buildingData` and `areaData` to `MapView`.

**Step 4: Verify upload flow works end-to-end**

Run both servers. Upload a small GeoJSON. Click Fetch Buildings. Buildings should appear on map.

**Step 5: Commit**

```bash
git add frontend/src/
git commit -m "feat: add area selection panel with GeoJSON upload"
```

---

## Task 7: Data Summary Panel

**Files:**
- Create: `frontend/src/components/DataSummary.tsx`
- Modify: `frontend/src/App.tsx`

**Step 1: Create DataSummary component**

`frontend/src/components/DataSummary.tsx`:
```tsx
import type { BuildingMetadata } from '../types';

interface DataSummaryProps {
  metadata: BuildingMetadata | null;
  onExport: () => void;
  opacity: number;
  onOpacityChange: (v: number) => void;
}

export function DataSummary({ metadata, onExport, opacity, onOpacityChange }: DataSummaryProps) {
  if (!metadata) return null;

  return (
    <div className="absolute top-4 right-4 bg-white/95 backdrop-blur rounded-lg shadow-lg p-4 w-72 z-10">
      <h3 className="font-semibold text-gray-800 mb-2">
        {metadata.total_buildings.toLocaleString()} Buildings
      </h3>

      {metadata.truncated && (
        <div className="text-amber-600 text-xs mb-2">Display limit reached</div>
      )}

      <div className="text-sm text-gray-600 space-y-1 mb-3">
        {metadata.avg_height !== null && (
          <div>Height: {metadata.avg_height}m avg ({metadata.height_coverage_pct}% coverage)</div>
        )}
        <div>Floors: {metadata.floor_coverage_pct}% coverage</div>
        <div>Classes: {metadata.class_coverage_pct}% coverage</div>

        {Object.keys(metadata.source_breakdown).length > 0 && (
          <div className="mt-2">
            <div className="font-medium text-gray-700">Sources</div>
            {Object.entries(metadata.source_breakdown)
              .sort(([, a], [, b]) => b - a)
              .map(([source, count]) => (
                <div key={source} className="ml-2">
                  {source}: {Math.round(count / metadata.total_buildings * 100)}%
                </div>
              ))}
          </div>
        )}
      </div>

      <div className="mb-3">
        <label className="text-xs text-gray-500">Opacity</label>
        <input
          type="range"
          min="0"
          max="1"
          step="0.1"
          value={opacity}
          onChange={e => onOpacityChange(parseFloat(e.target.value))}
          className="w-full"
        />
      </div>

      <button
        onClick={onExport}
        className="w-full px-3 py-2 bg-green-600 hover:bg-green-700 text-white rounded text-sm font-medium transition"
      >
        Download GeoJSON
      </button>

      <div className="mt-2 text-xs text-gray-400">
        Overture {metadata.overture_release}
      </div>
    </div>
  );
}
```

**Step 2: Wire into App.tsx**

Add DataSummary to App with metadata from API response and export handler that calls `/api/export`.

**Step 3: Verify panel appears after fetching buildings**

Expected: Right-side panel with stats, opacity slider, download button.

**Step 4: Commit**

```bash
git add frontend/src/
git commit -m "feat: add data summary panel with stats and export"
```

---

## Task 8: Drawing Tools on Map

**Files:**
- Create: `frontend/src/components/DrawControl.tsx`
- Modify: `frontend/src/components/AreaSelector.tsx`
- Modify: `frontend/src/App.tsx`

**Step 1: Create DrawControl component using editable-layers**

`frontend/src/components/DrawControl.tsx`:
```tsx
import { useState, useMemo } from 'react';
import { EditableGeoJsonLayer, DrawPolygonMode, DrawRectangleMode, ViewMode } from '@deck.gl-community/editable-layers';

type DrawMode = 'view' | 'polygon' | 'rectangle';

interface DrawControlProps {
  onDrawComplete: (features: GeoJSON.FeatureCollection) => void;
}

const MODES = {
  view: ViewMode,
  polygon: DrawPolygonMode,
  rectangle: DrawRectangleMode,
};

export function useDrawLayer({ onDrawComplete }: DrawControlProps) {
  const [mode, setMode] = useState<DrawMode>('view');
  const [drawData, setDrawData] = useState<GeoJSON.FeatureCollection>({
    type: 'FeatureCollection',
    features: [],
  });

  const layer = useMemo(() => new EditableGeoJsonLayer({
    id: 'draw-layer',
    data: drawData,
    mode: new MODES[mode](),
    selectedFeatureIndexes: [],
    onEdit: ({ updatedData, editType }: any) => {
      setDrawData(updatedData);
      if (editType === 'addFeature') {
        onDrawComplete(updatedData);
        setMode('view');
      }
    },
    getFillColor: [255, 165, 0, 40],
    getLineColor: [255, 165, 0, 255],
    getLineWidth: 2,
    lineWidthUnits: 'pixels' as const,
  }), [mode, drawData, onDrawComplete]);

  return { layer, mode, setMode, clearDraw: () => setDrawData({ type: 'FeatureCollection', features: [] }) };
}
```

**Step 2: Add draw buttons to AreaSelector**

Add polygon/rectangle draw buttons alongside the file upload button. When user selects a draw mode, it activates in the map.

**Step 3: Integrate draw layer into MapView**

Pass the draw layer from `useDrawLayer` hook into the layers array in MapView.

**Step 4: Verify drawing works**

Click "Draw Polygon" -> draw on map -> area appears -> click "Fetch Buildings".

**Step 5: Commit**

```bash
git add frontend/src/
git commit -m "feat: add polygon/rectangle drawing tools for area selection"
```

---

## Task 9: Static File Serving for Production

**Files:**
- Modify: `backend/app/main.py`
- Create: `Dockerfile`
- Create: `docker-compose.yml`

**Step 1: Add static file serving to FastAPI**

Add to `backend/app/main.py`:
```python
import os
from pathlib import Path
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse

# After all API routes are registered:
frontend_dist = Path(__file__).parent.parent.parent / "frontend" / "dist"
if frontend_dist.exists():
    app.mount("/assets", StaticFiles(directory=frontend_dist / "assets"), name="assets")

    @app.get("/{path:path}")
    async def serve_spa(path: str):
        file_path = frontend_dist / path
        if file_path.exists() and file_path.is_file():
            return FileResponse(file_path)
        return FileResponse(frontend_dist / "index.html")
```

**Step 2: Create docker-compose.yml for local dev**

```yaml
services:
  backend:
    build:
      context: .
      dockerfile: Dockerfile
      target: dev
    ports:
      - "8000:8000"
    volumes:
      - ./backend:/app/backend
    command: uv run uvicorn backend.app.main:app --host 0.0.0.0 --reload

  frontend:
    image: node:22-slim
    working_dir: /app
    ports:
      - "5173:5173"
    volumes:
      - ./frontend:/app
    command: sh -c "npm install && npm run dev -- --host"
```

**Step 3: Create Dockerfile**

```dockerfile
FROM python:3.11-slim AS base
WORKDIR /app
COPY pyproject.toml .
RUN pip install uv && uv sync

FROM base AS dev
COPY backend/ backend/

FROM node:22-slim AS frontend-build
WORKDIR /app
COPY frontend/package*.json ./
RUN npm ci
COPY frontend/ .
RUN npm run build

FROM base AS production
COPY backend/ backend/
COPY --from=frontend-build /app/dist frontend/dist
EXPOSE 8000
CMD ["uv", "run", "uvicorn", "backend.app.main:app", "--host", "0.0.0.0"]
```

**Step 4: Verify docker-compose up works**

Run: `docker-compose up`
Expected: Both services start, app accessible at :5173 (dev) or :8000 (prod)

**Step 5: Commit**

```bash
git add Dockerfile docker-compose.yml backend/app/main.py
git commit -m "feat: add Docker setup and static file serving"
```

---

## Task 10: Polish and Final Integration

**Step 1: Add loading state to map** - spinner overlay while fetching buildings

**Step 2: Add error handling** - toast/alert for API failures

**Step 3: Fit map to selected area** - when GeoJSON uploaded or area drawn, zoom to fit bounds

**Step 4: Add Tailwind global styles** - dark panel variants, consistent spacing

**Step 5: Final end-to-end test**
1. Start both servers
2. Upload a GeoJSON file
3. Select features
4. Fetch buildings
5. Verify buildings render on map
6. Hover buildings for tooltip
7. Check stats panel
8. Download GeoJSON export
9. Draw a polygon and fetch buildings for it

**Step 6: Commit**

```bash
git add -A
git commit -m "feat: polish UI with loading states, error handling, and map fitting"
```

---

## Summary

| Task | What | Key Files |
|------|------|-----------|
| 1 | Project scaffolding | pyproject.toml, main.py, App.tsx |
| 2 | DuckDB query engine | core/duckdb.py, core/config.py |
| 3 | Building query function | core/queries.py |
| 4 | API endpoints | api/buildings.py, schemas.py |
| 5 | Full-screen Deck.gl map | MapView.tsx, useMapState.ts |
| 6 | Area selection panel | AreaSelector.tsx |
| 7 | Data summary panel | DataSummary.tsx |
| 8 | Drawing tools | DrawControl.tsx |
| 9 | Docker + production serving | Dockerfile, docker-compose.yml |
| 10 | Polish and integration | Loading, errors, map fitting |
